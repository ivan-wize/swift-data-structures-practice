# Docker and Kubernetes Cheat Sheet

# ---------------------------------------------------------------------------
# What is Docker?
# ---------------------------------------------------------------------------
# Docker is a tool designed to make it easier to create, deploy, and run applications
# by using containers. Containers are lightweight, portable, and self-contained environments.
# Each container includes everything an application needs to run: libraries, system tools,
# code, and runtime. Docker ensures your application behaves the same way regardless of
# where it runs—your computer, a server, or in the cloud.
#
# Key features of Docker:
# 1. **Images:** Prepackaged templates that define what goes into a container.
# 2. **Containers:** Running instances of images.
# 3. **Docker Hub:** A repository to find and share container images.
# 4. **Volumes:** Shared storage between your computer and containers.

# ---------------------------------------------------------------------------
# Docker Basics: Common Commands and Concepts
# ---------------------------------------------------------------------------

# 1. Docker Images
# Images are like blueprints for your containers. They define all the settings and tools
# your application needs. You can build custom images or pull existing ones from Docker Hub.
# Build an image from a Dockerfile
# docker build -t <image_name>:<tag> .

# List all Docker images (all the blueprints you have)
# docker images

# Remove a Docker image (delete a blueprint you no longer need)
# docker rmi <image_name>

# Pull an image from Docker Hub (download a blueprint from the internet)
# docker pull <image_name>

# 2. Docker Containers
# A container is a running instance of an image. Containers are isolated environments
# where your app runs, separate from your host machine.
# Run a container from an image
# docker run -d --name <container_name> -p <host_port>:<container_port> <image_name>

# List all running containers
# docker ps

# List all containers (both running and stopped)
# docker ps -a

# Stop a running container
# docker stop <container_id>

# Remove a container (delete the isolated environment)
# docker rm <container_id>

# View logs of a container (see what the app is doing inside the container)
# docker logs <container_id>

# Access a running container's shell (interact directly with the container's system)
# docker exec -it <container_id> /bin/bash

# 3. Docker Volumes
# Volumes are used to persist data generated by or used by containers. They allow data to
# survive even if the container is deleted.
# Create a volume
# docker volume create <volume_name>

# List all volumes
# docker volume ls

# Remove a volume
# docker volume rm <volume_name>

# Mount a volume to a container (link the container to the volume for data storage)
# docker run -d -v <volume_name>:<container_path> <image_name>

# 4. Docker Compose
# Docker Compose is a tool for defining and running multi-container Docker applications.
# Use a YAML file to configure the application’s services, networks, and volumes.
# Start services defined in docker-compose.yml
# docker-compose up -d

# Stop services
# docker-compose down

# View logs from services
# docker-compose logs

# Rebuild and start services
# docker-compose up --build

# ---------------------------------------------------------------------------
# What is Kubernetes?
# ---------------------------------------------------------------------------
# Kubernetes (often called "K8s") is an open-source system for automating the deployment,
# scaling, and management of containerized applications. It acts as an orchestrator,
# ensuring that your app's containers are running correctly, can communicate with each other,
# and are distributed across available resources efficiently.
#
# Key features of Kubernetes:
# 1. **Pods:** The smallest unit in Kubernetes, representing a single container or a group of
#    containers that share the same network and storage.
# 2. **Deployments:** Define how to run and update your application.
# 3. **Services:** Expose your application to the network and ensure communication between pods.
# 4. **ConfigMaps & Secrets:** Manage configuration and sensitive data.
# 5. **Nodes:** Machines (virtual or physical) in the Kubernetes cluster that run your app.

# ---------------------------------------------------------------------------
# Kubernetes Basics: Common Commands and Concepts
# ---------------------------------------------------------------------------

# 1. kubectl Commands
# "kubectl" is the command-line tool used to interact with Kubernetes clusters.
# Check cluster information (get an overview of your Kubernetes setup)
# kubectl cluster-info

# Get nodes in the cluster (see the machines available for running apps)
# kubectl get nodes

# View pods in a namespace (pods are the running units in Kubernetes)
# kubectl get pods -n <namespace>

# Describe a specific pod (see details about a particular pod)
# kubectl describe pod <pod_name> -n <namespace>

# View logs of a pod (check what the application in the pod is doing)
# kubectl logs <pod_name> -n <namespace>

# Execute a command in a running pod (e.g., open a shell inside the pod)
# kubectl exec -it <pod_name> -n <namespace> -- /bin/bash

# Delete a pod (remove the application instance)
# kubectl delete pod <pod_name> -n <namespace>

# 2. Managing Deployments
# Deployments are templates for running and scaling your app’s pods.
# Create a deployment
# kubectl create deployment <deployment_name> --image=<image_name>

# View all deployments
# kubectl get deployments -n <namespace>

# Scale a deployment (adjust the number of pods for your app)
# kubectl scale deployment <deployment_name> --replicas=<number_of_replicas> -n <namespace>

# Update a deployment's image (use a new version of your app)
# kubectl set image deployment/<deployment_name> <container_name>=<new_image> -n <namespace>

# Roll back a deployment (return to a previous version if something breaks)
# kubectl rollout undo deployment/<deployment_name> -n <namespace>

# 3. Services
# Services allow communication between different parts of your application or make it accessible externally.
# View services in a namespace
# kubectl get services -n <namespace>

# Expose a deployment as a service (make your app accessible to the network)
# kubectl expose deployment <deployment_name> --type=<service_type> --port=<port> -n <namespace>

# Delete a service
# kubectl delete service <service_name> -n <namespace>

# 4. ConfigMaps and Secrets
# ConfigMaps and Secrets store application configurations and sensitive data separately from the code.
# Create a ConfigMap from a file (store configuration settings)
# kubectl create configmap <configmap_name> --from-file=<file_path> -n <namespace>

# Create a Secret from literal values (store sensitive data securely)
# kubectl create secret generic <secret_name> --from-literal=<key>=<value> -n <namespace>

# View ConfigMaps in a namespace
# kubectl get configmaps -n <namespace>

# View Secrets in a namespace
# kubectl get secrets -n <namespace>

# 5. YAML Manifests
# YAML files define what Kubernetes should do. They are used to describe applications and resources.
# Apply a YAML manifest (create or update resources based on the file)
# kubectl apply -f <file.yaml> -n <namespace>

# Delete resources defined in a YAML file
# kubectl delete -f <file.yaml> -n <namespace>

# ---------------------------------------------------------------------------
# Best Practices
# ---------------------------------------------------------------------------
# Docker:
# 1. Use lightweight base images (e.g., alpine) to reduce image size.
# 2. Keep Dockerfiles clean and avoid hardcoding sensitive information.
# 3. Use multi-stage builds to optimize build time and image size.
# 4. Regularly clean up unused images, containers, and volumes.

# Kubernetes:
# 1. Use namespaces to organize resources and avoid conflicts.
# 2. Implement resource quotas and limits to manage resource usage.
# 3. Use ConfigMaps and Secrets to manage configurations and sensitive data.
# 4. Monitor and log resources to identify and resolve issues promptly.
# 5. Automate deployments using CI/CD pipelines and GitOps practices.
